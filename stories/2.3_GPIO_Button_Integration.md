# Story 2.3: GPIO Button Integration

**Epic:** 2 - Perception & Sensing

**Description:**
Integrate the physical GPIO button mounted on the robot. This button will be pressed by students to confirm they have taken the delivered paper during the delivery phase.

**Tasks:**
1. Identify the GPIO pin connected to the button
   - Check physical wiring on robot
   - Document pin number in `yahoo/config/pins.json`
2. Create a new module: `yahoo/io/button.py`
3. Implement `Button` class with:
   - Initialization with GPIO pin number
   - `wait_for_press(timeout=None)` - Blocking wait for button press
   - `is_pressed()` - Non-blocking check of button state
   - Proper debouncing to avoid false triggers
   - Simulation mode support (keyboard input for testing)
4. Test button physically:
   - Verify button press is detected
   - Test debouncing (rapid presses handled correctly)
   - Check pull-up/pull-down configuration
5. Create test script: `tests/test_button.py`
6. Add LED feedback when button pressed (brief flash)

**Acceptance Criteria:**
- A `yahoo/io/button.py` module exists with `Button` class
- GPIO pin for button is documented in `pins.json`
- Physical button press is reliably detected on Raspberry Pi
- Debouncing prevents false triggers from single press
- `wait_for_press(timeout=30)` returns True when pressed, False on timeout
- Simulation mode allows keyboard input (spacebar) for testing on Mac
- Test script demonstrates:
  - Button press detection
  - Timeout handling
  - Debouncing effectiveness
- LED provides visual feedback on button press

**Technical Details:**

**GPIO Configuration:**
```python
import RPi.GPIO as GPIO

# Common setup for button with pull-up resistor
GPIO.setmode(GPIO.BCM)
GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Button is pressed when pin reads LOW (grounded)
if GPIO.input(pin) == GPIO.LOW:
    # Button pressed
```

**Debouncing:**
```python
# Software debouncing approach
def wait_for_press(self, timeout=None):
    start = time.time()
    while timeout is None or (time.time() - start) < timeout:
        if GPIO.input(self.pin) == GPIO.LOW:
            time.sleep(0.05)  # Debounce delay
            if GPIO.input(self.pin) == GPIO.LOW:  # Still pressed
                return True
        time.sleep(0.01)
    return False
```

**Simulation Mode:**
```python
# For testing on Mac
if self.simulate:
    print("Press SPACE to simulate button press...")
    # Use keyboard input or mock return value
```

**Hardware Checklist:**
```
[ ] Locate physical button on robot
[ ] Identify GPIO pin connection
[ ] Verify button type (normally open/closed)
[ ] Check if pull-up/pull-down resistor needed
[ ] Test physical button actuation
[ ] Update pins.json with pin number
```

**Design Considerations:**
- **Button type:** Tactile push button (momentary contact)
- **Mounting:** Should be easily accessible to students
- **Feedback:** LED flash confirms press was registered
- **Timeout:** Prevents infinite waiting if student doesn't press
- **Debouncing:** Essential for clean detection

**Integration Points:**
- Will be called by delivery mission (Story 3.1)
- Uses `LEDController` for visual feedback
- Configuration loaded from `pins.json`
- Works with `Robot` class simulation mode

**Pin Configuration Example:**
```json
{
  "button": {
    "delivery_confirm": {
      "pin": 17,
      "description": "Student confirmation button - BCM GPIO 17 (Physical Pin 11)",
      "pull": "up",
      "active": "low"
    }
  }
}
```
